/*
 * Copyright 2001-2008 Artima, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.scalatest.matchers

import org.scalatest._
import org.scalatest.verb.ShouldVerb
import Helper._

trait SizeShouldMatchers extends SizeMatchers with ShouldVerb {

  /**
   * This class is part of the ScalaTest matchers DSL. Please see the documentation for <a href="ShouldMatchers.html"><code>ShouldMatchers</code></a> or <a href="MustMatchers.html"><code>MustMatchers</code></a> for an overview of
   * the matchers DSL.
   *
   * <p>
   * This class is used in conjunction with an implicit conversion to enable <code>should</code> methods to
   * be invoked on <code>AnyRef</code> objects that can be implicitly converted to type <code>SizeWrapper</code>.
   * Trait <code>ShouldMatchers</code> includes implicit conversions from several types, including many structural types, to <code>SizeWrapper</code>.
   * </p>
   *
   * @author Bill Venners
   */
  final class SizeShouldWrapper[A <: AnyRef <% SizeWrapper](left: A) {

    /**
     * This method enables syntax such as the following:
     *
     * <pre class="stHighlight">
     * objectWithSize should equal (3)
     *                ^
     * </pre>
     */
    def should(rightMatcher: Matcher[A]) {
      ShouldMatchers.ShouldMethodHelper.shouldMatcher(left, rightMatcher)
    }

    /**
     * This method enables syntax such as the following:
     *
     * <pre class="stHighlight">
     * result should not have size (3)
     *        ^
     * </pre>
     */
    def should(notWord: NotWord): ResultOfNotWordForSizeWrapper[A] =
      new ResultOfNotWordForSizeWrapper(left, false)

    /**
     * This method enables syntax such as the following:
     *
     * <pre class="stHighlight">
     * result should have size (3)
     *        ^
     * </pre>
     */
    def should(haveWord: HaveWord): ResultOfHaveWordForSizeWrapper[A] =
      new ResultOfHaveWordForSizeWrapper(left, true)

    // TODO I just added this. Didn't do a test for it.
    /**
     * This method enables syntax such as the following:
     *
     * <pre class="stHighlight">
     * result should be theSameInstanceAs anotherObject
     *        ^
     * </pre>
     */
    def should(beWord: BeWord): ResultOfBeWordForAnyRef[A] = new ResultOfBeWordForAnyRef[A](left, true)
  }
  
  // Implicitly just used to trigger the addition of the should method. The LengthShouldWrapper
  // doesn't actually convert them, just passes it through. The conversion that happens here is to LengthShouldWrapper,
  // and later, inside ResultOfHaveWordForLengthWrapper, the implicit conversion from T to LengthWrapper takes place. So
  // weirdly enough, here strings are treated structurally for the implicit that adds the should, but later they are
  // treated nominally by the implicit conversion from plain old String to StringLengthWrapper. So when length is
  // ultimately invoked up in ResultOfHaveWordForLengthWrapper, it is done directly, not with reflection. That's my
  // theory anyway.

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>getSize</code> method that results in <code>Int</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   */
  implicit def convertHasIntGetSizeMethodToSizeShouldWrapper[T <: AnyRef { def getSize(): Int}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>getSize</code> parameterless method that results in <code>Int</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   * */
  implicit def convertHasIntGetSizeParameterlessMethodToSizeShouldWrapper[T <: AnyRef { def getSize: Int}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>getSize</code> <code>val</code> of type <code>Int</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   */
  implicit def convertHasIntGetSizeFieldToSizeShouldWrapper[T <: AnyRef { val getSize: Int}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>size</code> <code>val</code> of type <code>Int</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   */
  implicit def convertHasIntSizeFieldToSizeShouldWrapper[T <: AnyRef { val size: Int}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>size</code> method that results in <code>Int</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   */
  implicit def convertHasIntSizeMethodToSizeShouldWrapper[T <: AnyRef { def size(): Int}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>size</code> parameterless method that results in <code>Int</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   * */
  implicit def convertHasIntSizeParameterlessMethodToSizeShouldWrapper[T <: AnyRef { def size: Int}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>getSize</code> method that results in <code>Long</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   */
  implicit def convertHasLongGetSizeMethodToSizeShouldWrapper[T <: AnyRef { def getSize(): Long}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>getSize</code> parameterless method that results in <code>Long</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   * */
  implicit def convertHasLongGetSizeParameterlessMethodToSizeShouldWrapper[T <: AnyRef { def getSize: Long}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>getSize</code> <code>val</code> of type <code>Long</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   */
  implicit def convertHasLongGetSizeFieldToSizeShouldWrapper[T <: AnyRef { val getSize: Long}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>size</code> <code>val</code> type <code>Long</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   */
  implicit def convertHasLongSizeFieldToSizeShouldWrapper[T <: AnyRef { val size: Long}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>size</code> method that results in <code>Long</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   */
  implicit def convertHasLongSizeMethodToSizeShouldWrapper[T <: AnyRef { def size(): Long}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)

  /**
   * Implicitly converts an <code>AnyRef</code> of type <code>T</code> whose structure includes
   * a <code>size</code> parameterless method that results in <code>Long</code>
   * to a <code>SizeShouldWrapper[T]</code>, to enable <code>should</code> methods to be invokable on that object.
   * */
  implicit def convertHasLongSizeParameterlessMethodToSizeShouldWrapper[T <: AnyRef { def size: Long}](o: T): SizeShouldWrapper[T] = new SizeShouldWrapper[T](o)
}